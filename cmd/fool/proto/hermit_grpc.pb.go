// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (c) 2026 Jared Redh. All rights reserved.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.1
// source: hermit.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Hermit_Ping_FullMethodName       = "/hermit.Hermit/Ping"
	Hermit_Benchmark_FullMethodName  = "/hermit.Hermit/Benchmark"
	Hermit_Login_FullMethodName      = "/hermit.Hermit/Login"
	Hermit_ServerInfo_FullMethodName = "/hermit.Hermit/ServerInfo"
	Hermit_KvSet_FullMethodName      = "/hermit.Hermit/KvSet"
	Hermit_KvGet_FullMethodName      = "/hermit.Hermit/KvGet"
	Hermit_KvList_FullMethodName     = "/hermit.Hermit/KvList"
	Hermit_SqlInsert_FullMethodName  = "/hermit.Hermit/SqlInsert"
	Hermit_SqlQuery_FullMethodName   = "/hermit.Hermit/SqlQuery"
	Hermit_DbStats_FullMethodName    = "/hermit.Hermit/DbStats"
)

// HermitClient is the client API for Hermit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HermitClient interface {
	// Ping returns server liveness + round-trip timing metadata.
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// Benchmark runs a latency test: server timestamps request receipt and
	// response dispatch so the client can compute wire time vs processing time.
	Benchmark(ctx context.Context, in *BenchmarkRequest, opts ...grpc.CallOption) (*BenchmarkResponse, error)
	// Login authenticates a client session. Hardcoded success for now.
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// ServerInfo returns server metadata (version, region, uptime).
	ServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error)
	// KvSet stores a value under a key (zstd-compressed server-side).
	KvSet(ctx context.Context, in *KvSetRequest, opts ...grpc.CallOption) (*KvSetResponse, error)
	// KvGet retrieves a value by key (decompressed).
	KvGet(ctx context.Context, in *KvGetRequest, opts ...grpc.CallOption) (*KvGetResponse, error)
	// KvList returns all keys in the document store.
	KvList(ctx context.Context, in *KvListRequest, opts ...grpc.CallOption) (*KvListResponse, error)
	// SqlInsert enqueues a row for at-least-once write into the relational store.
	SqlInsert(ctx context.Context, in *SqlInsertRequest, opts ...grpc.CallOption) (*SqlInsertResponse, error)
	// SqlQuery performs an eventual-consistent scan with optional key filter.
	SqlQuery(ctx context.Context, in *SqlQueryRequest, opts ...grpc.CallOption) (*SqlQueryResponse, error)
	// DbStats returns combined stats for both stores.
	DbStats(ctx context.Context, in *DbStatsRequest, opts ...grpc.CallOption) (*DbStatsResponse, error)
}

type hermitClient struct {
	cc grpc.ClientConnInterface
}

func NewHermitClient(cc grpc.ClientConnInterface) HermitClient {
	return &hermitClient{cc}
}

func (c *hermitClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, Hermit_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) Benchmark(ctx context.Context, in *BenchmarkRequest, opts ...grpc.CallOption) (*BenchmarkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BenchmarkResponse)
	err := c.cc.Invoke(ctx, Hermit_Benchmark_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, Hermit_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) ServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerInfoResponse)
	err := c.cc.Invoke(ctx, Hermit_ServerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) KvSet(ctx context.Context, in *KvSetRequest, opts ...grpc.CallOption) (*KvSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KvSetResponse)
	err := c.cc.Invoke(ctx, Hermit_KvSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) KvGet(ctx context.Context, in *KvGetRequest, opts ...grpc.CallOption) (*KvGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KvGetResponse)
	err := c.cc.Invoke(ctx, Hermit_KvGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) KvList(ctx context.Context, in *KvListRequest, opts ...grpc.CallOption) (*KvListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KvListResponse)
	err := c.cc.Invoke(ctx, Hermit_KvList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) SqlInsert(ctx context.Context, in *SqlInsertRequest, opts ...grpc.CallOption) (*SqlInsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SqlInsertResponse)
	err := c.cc.Invoke(ctx, Hermit_SqlInsert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) SqlQuery(ctx context.Context, in *SqlQueryRequest, opts ...grpc.CallOption) (*SqlQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SqlQueryResponse)
	err := c.cc.Invoke(ctx, Hermit_SqlQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hermitClient) DbStats(ctx context.Context, in *DbStatsRequest, opts ...grpc.CallOption) (*DbStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbStatsResponse)
	err := c.cc.Invoke(ctx, Hermit_DbStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HermitServer is the server API for Hermit service.
// All implementations must embed UnimplementedHermitServer
// for forward compatibility.
type HermitServer interface {
	// Ping returns server liveness + round-trip timing metadata.
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// Benchmark runs a latency test: server timestamps request receipt and
	// response dispatch so the client can compute wire time vs processing time.
	Benchmark(context.Context, *BenchmarkRequest) (*BenchmarkResponse, error)
	// Login authenticates a client session. Hardcoded success for now.
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// ServerInfo returns server metadata (version, region, uptime).
	ServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error)
	// KvSet stores a value under a key (zstd-compressed server-side).
	KvSet(context.Context, *KvSetRequest) (*KvSetResponse, error)
	// KvGet retrieves a value by key (decompressed).
	KvGet(context.Context, *KvGetRequest) (*KvGetResponse, error)
	// KvList returns all keys in the document store.
	KvList(context.Context, *KvListRequest) (*KvListResponse, error)
	// SqlInsert enqueues a row for at-least-once write into the relational store.
	SqlInsert(context.Context, *SqlInsertRequest) (*SqlInsertResponse, error)
	// SqlQuery performs an eventual-consistent scan with optional key filter.
	SqlQuery(context.Context, *SqlQueryRequest) (*SqlQueryResponse, error)
	// DbStats returns combined stats for both stores.
	DbStats(context.Context, *DbStatsRequest) (*DbStatsResponse, error)
	mustEmbedUnimplementedHermitServer()
}

// UnimplementedHermitServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHermitServer struct{}

func (UnimplementedHermitServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedHermitServer) Benchmark(context.Context, *BenchmarkRequest) (*BenchmarkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Benchmark not implemented")
}
func (UnimplementedHermitServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedHermitServer) ServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ServerInfo not implemented")
}
func (UnimplementedHermitServer) KvSet(context.Context, *KvSetRequest) (*KvSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvSet not implemented")
}
func (UnimplementedHermitServer) KvGet(context.Context, *KvGetRequest) (*KvGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvGet not implemented")
}
func (UnimplementedHermitServer) KvList(context.Context, *KvListRequest) (*KvListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvList not implemented")
}
func (UnimplementedHermitServer) SqlInsert(context.Context, *SqlInsertRequest) (*SqlInsertResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SqlInsert not implemented")
}
func (UnimplementedHermitServer) SqlQuery(context.Context, *SqlQueryRequest) (*SqlQueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SqlQuery not implemented")
}
func (UnimplementedHermitServer) DbStats(context.Context, *DbStatsRequest) (*DbStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DbStats not implemented")
}
func (UnimplementedHermitServer) mustEmbedUnimplementedHermitServer() {}
func (UnimplementedHermitServer) testEmbeddedByValue()                {}

// UnsafeHermitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HermitServer will
// result in compilation errors.
type UnsafeHermitServer interface {
	mustEmbedUnimplementedHermitServer()
}

func RegisterHermitServer(s grpc.ServiceRegistrar, srv HermitServer) {
	// If the following call panics, it indicates UnimplementedHermitServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Hermit_ServiceDesc, srv)
}

func _Hermit_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_Benchmark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BenchmarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).Benchmark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_Benchmark_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).Benchmark(ctx, req.(*BenchmarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_ServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).ServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_ServerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).ServerInfo(ctx, req.(*ServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_KvSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).KvSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_KvSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).KvSet(ctx, req.(*KvSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_KvGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).KvGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_KvGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).KvGet(ctx, req.(*KvGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_KvList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KvListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).KvList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_KvList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).KvList(ctx, req.(*KvListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_SqlInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SqlInsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).SqlInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_SqlInsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).SqlInsert(ctx, req.(*SqlInsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_SqlQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SqlQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).SqlQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_SqlQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).SqlQuery(ctx, req.(*SqlQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hermit_DbStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DbStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HermitServer).DbStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hermit_DbStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HermitServer).DbStats(ctx, req.(*DbStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Hermit_ServiceDesc is the grpc.ServiceDesc for Hermit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hermit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hermit.Hermit",
	HandlerType: (*HermitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Hermit_Ping_Handler,
		},
		{
			MethodName: "Benchmark",
			Handler:    _Hermit_Benchmark_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Hermit_Login_Handler,
		},
		{
			MethodName: "ServerInfo",
			Handler:    _Hermit_ServerInfo_Handler,
		},
		{
			MethodName: "KvSet",
			Handler:    _Hermit_KvSet_Handler,
		},
		{
			MethodName: "KvGet",
			Handler:    _Hermit_KvGet_Handler,
		},
		{
			MethodName: "KvList",
			Handler:    _Hermit_KvList_Handler,
		},
		{
			MethodName: "SqlInsert",
			Handler:    _Hermit_SqlInsert_Handler,
		},
		{
			MethodName: "SqlQuery",
			Handler:    _Hermit_SqlQuery_Handler,
		},
		{
			MethodName: "DbStats",
			Handler:    _Hermit_DbStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hermit.proto",
}
